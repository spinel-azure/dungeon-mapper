<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Dungeon Mapping Assist (27x27)</title>
  <style>
    :root{
      --bg:#ffffff;
      --ui:#f4f5f7;
      --ui2:#e9eaee;
      --txt:#111;
      --muted:#666;
      --accent:#2563eb;
      --grid:#b0b0b0;
    }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Sans", "Yu Gothic", sans-serif;
      color:var(--txt);
      background:var(--bg);
    }
    header{
      padding:10px 12px;
      background:var(--ui);
      border-bottom:1px solid var(--ui2);
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .group{
      display:flex;
      gap:8px;
      align-items:center;
      padding:6px 8px;
      background:#fff;
      border:1px solid var(--ui2);
      border-radius:10px;
    }
    .group .label{
      font-size:12px;
      color:var(--muted);
      margin-right:4px;
      user-select:none;
      white-space:nowrap;
    }
    button{
      border:1px solid var(--ui2);
      background:#fff;
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      user-select:none;
    }
    button:hover{ border-color:#cdd0d8; }
    button.active{
      border-color:var(--accent);
      outline:2px solid rgba(37,99,235,.15);
    }
    button.danger{ color:#b91c1c; }
    input[type="file"]{ font-size:13px; }
    select, input[type="text"], input[type="number"]{
      border:1px solid var(--ui2);
      border-radius:10px;
      padding:6px 10px;
      font-size:13px;
      background:#fff;
    }
    .swatches{ display:flex; gap:6px; align-items:center; }
    .swatch{
      width:22px; height:22px;
      border-radius:7px;
      border:1px solid #cfd2da;
      cursor:pointer;
      position:relative;
      box-sizing:border-box;
    }
    .swatch.selected::after{
      content:"";
      position:absolute;
      inset:-3px;
      border:2px solid var(--accent);
      border-radius:9px;
      pointer-events:none;
    }
    .wallSwatches .swatch{ width:22px; height:22px; }
    .sep{ width:1px; height:26px; background:var(--ui2); margin:0 4px; }

    main{
      padding:12px;
      display:flex;
      justify-content:center;   /* â˜… ä¸­å¤®å¯„ã› */
      align-items:flex-start;
      gap:12px;
      flex-wrap:wrap;
    }
    .panel{
      background:#fff;
      border:1px solid var(--ui2);
      border-radius:14px;
      padding:10px;
    }
    #canvasWrap{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center; /* â˜… ã‚¿ã‚¤ãƒˆãƒ«ã‚‚ä¸­å¤® */
    }
    #titleRow{
      width:100%;
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
    }
    #mapTitle{
      width:min(580px, 92vw);
      max-width:580px;
      font-size:16px;
      padding:8px 12px;
    }
    #mapTitle::placeholder{ color:#9ca3af; }

    canvas{
      background:#fff;
      border-radius:10px;
      display:block;
      touch-action:none;
      box-shadow: 0 1px 0 rgba(0,0,0,.02);
    }

    

    #canvasStack{
      position:relative;
      width:580px;
      height:580px;
    }
    #canvasStack canvas{
      position:absolute;
      left:0; top:0;
    }
    #overlay{
      background:transparent;
      pointer-events:none;
      box-shadow:none;
    }

.hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
      max-width:420px;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 1px 6px;
      font-size: 12px;
      color:#111;
    }

    #coordRow{
      display:flex;
      justify-content:flex-end;
      align-items:center;
      gap:6px;
      margin-top:8px;
    }
    #highlightToggle{
      font-size:12px;
      padding:4px 8px;
      border-radius:10px;
      background:var(--ui);
      border:1px solid var(--ui2);
      user-select:none;
      white-space:nowrap;
    }
    #coordDisplay{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px;
      color:var(--muted);
      background:var(--ui);
      border:1px solid var(--ui2);
      border-radius:10px;
      padding:4px 8px;
      min-width:92px;
      text-align:right;
      user-select:none;
    }

  
    /* Bottom memo (3 lines) */
    #bottomMemoWrap{
      width:580px;
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:stretch;
    }
    #bottomMemoLabel{
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .memoHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    #bottomMemoCounter{
      font-size:12px;
      color:var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    #bottomMemo{
      width:100%;
      box-sizing:border-box;
      border:1px solid var(--ui2);
      border-radius:10px;
      padding:8px 10px;
      font-size:13px;
      line-height:1.35;
      resize:none;
      height: calc(1.35em * 3 + 20px);
      background:#fff;
    }
    #bottomMemo::placeholder{ color:#9ca3af; }

  </style>
</head>
<body>

<header>
  <div class="group">
    <span class="label" id="lblTools">ãƒ„ãƒ¼ãƒ«</span>
    <button id="toolWall" class="active" title="æ ¼å­ã®è¾ºã«å£ç·šã‚’å¼•ã">å£ç·š</button>
    <button id="toolEraseWall" title="å£ç·šã‚’æ¶ˆã™">å£æ¶ˆã—</button>
    <button id="toolFill" title="ã‚»ãƒ«ã‚’å¡—ã‚‹">å¡—ã‚Š</button>
    <button id="toolEraseFill" title="å¡—ã‚Šã‚’æ¶ˆã™">å¡—æ¶ˆã—</button>
    <button id="bucketToggle" title="å¡—ã‚Š/å¡—æ¶ˆã—ã®ç¯„å›²(ãƒã‚±ãƒ„)ã€‚ã‚¹ãƒãƒ›ã¯ã“ã‚Œã‚’ON">ç¯„å›²</button>
    <button id="toolIcon" title="çµµæ–‡å­—ã‚¢ã‚¤ã‚³ãƒ³ã‚’ç½®ã">ã‚¢ã‚¤ã‚³ãƒ³</button>
    <button id="toolEraseIcon" title="ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ¶ˆã™">ã‚¢ã‚¤æ¶ˆã—</button>
    <button id="toolText" title="ã‚»ãƒ«ã«çŸ­ã„ãƒ¡ãƒ¢æ–‡å­—ã‚’å…¥ã‚Œã‚‹">æ–‡å­—</button>
  </div>

  <div class="group" id="langGroup">
    <span class="label">è¨€èª / Language</span>
    <select id="langSelect" title="UI language">
      <option value="ja">Japanese</option>
      <option value="en">English</option>
    </select>
  </div>

  <div class="group">
    <span class="label" id="lblFillColor">å¡—ã‚Šè‰²</span>
    <div class="swatches" id="swatches"></div>

    <span class="sep"></span>

    <span class="label" id="lblWallColor">å£è‰²</span>
    <div class="swatches wallSwatches" id="wallSwatches"></div>

    <span class="sep"></span>

    <span class="label" id="lblLineWidth">ç·šå¹…</span>
    <input id="wallWidth" type="number" min="2" max="4" value="4" style="width:72px" />

    <span class="sep"></span>

    <span class="label" id="lblLineStyle">ç·šç¨®</span>
    <select id="wallStyle" style="width:110px" title="Wall line style">
      <option value="solid">Solid</option>
      <option value="dashed">Dashed</option>
    </select>

    <span class="sep"></span>

    <span class="label" id="lblWallMark">ãƒãƒ¼ã‚¯</span>
    <select id="wallMark" style="width:110px" title="Wall mark">
      <option value="none">None</option>
      <option value="door">Door</option>
    </select>

  </div>

  <div class="group">
    <span class="label" id="lblIcons">ã‚¢ã‚¤ã‚³ãƒ³</span>
    <select id="iconType">
<option value="ğŸšª">ğŸšª Stairs</option>
<option value="âœ¨">âœ¨ Haken</option>
<option value="ğŸ‘¹">ğŸ‘¹ Enemy</option>
<option value="â—">â— Event</option>
<option value="â›²">â›² Fountain</option>
<option value="â˜ ">â˜  Remains</option>
<option value="ğŸ•³">ğŸ•³ Pitfall</option>
<option value="â™¨">â™¨ Heal</option>
<option value="ğŸ§°">ğŸ§° Treasure</option>
<option value="ğŸ‘¤">ğŸ‘¤ NPC</option>
<option value="âŒ">âŒ Danger</option>
<option value="ğŸ”¯">ğŸ”¯ Warp</option>
    </select>
    <input id="iconNote" type="text" placeholder="ãƒ¡ãƒ¢(ä»»æ„)" maxlength="20" style="width:180px" />
  </div>

  <div class="group">
    <span class="label" id="lblHistory">å±¥æ­´</span>
    <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
    <button id="redoBtn" title="Redo (Ctrl+Y / Ctrl+Shift+Z)">Redo</button>
    <button id="clearBtn" class="danger" title="å…¨æ¶ˆå»">å…¨æ¶ˆå»</button>
  </div>

  <div class="group">
    <span class="label" id="lblSaveExport">ä¿å­˜/å‡ºåŠ›</span>
    <button id="saveJsonBtn">JSONä¿å­˜</button>
    <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;">
      <input id="loadJsonInput" type="file" accept="application/json" style="display:none" />
      <span id="loadJsonSpan" style="padding:6px 10px;border:1px solid var(--ui2);border-radius:10px;background:#fff;">JSONèª­è¾¼</span>
    </label>
    <button id="exportPngBtn">PNGæ›¸å‡º</button>
    <button id="printBtn">å°åˆ·</button>
  </div>
</header>

<main>
  <div id="canvasWrap" class="panel">
    <div id="titleRow">
      <input id="mapTitle" type="text" placeholder="MAPåã‚’å…¥åŠ›ï¼ˆå°åˆ·ã«ã‚‚åæ˜ ï¼‰" />
    </div>
    <!-- â˜… 29x29ï¼ˆ1ãƒã‚¹ä½™ç™½ï¼‰: 580x580 -->
    <div id="canvasStack">
      <canvas id="map" width="580" height="580"></canvas>
      <canvas id="overlay" width="580" height="580"></canvas>
    </div>
    <div id="coordRow">
      <button id="highlightToggle" title="é¸æŠã‚»ãƒ«ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã‚’åˆ‡æ›¿">ãƒã‚¤ãƒ©ã‚¤ãƒˆ:ON</button>
      <div id="coordDisplay">X:-- Y:--</div>
    </div>

    <div id="bottomMemoWrap">
      <div class="memoHeader">
        <div id="bottomMemoLabel">ãƒ¡ãƒ¢ï¼ˆå°åˆ·ã€PNGã«ã‚‚åæ˜  / æœ€å¤§100æ–‡å­—ã¾ã§ï¼‰</div>
        <div id="bottomMemoCounter">ï¼ˆæ®‹ã‚Šï¼š100æ–‡å­—ï¼‰</div>
      </div>
      <textarea id="bottomMemo" rows="3" placeholder="ã“ã“ã«ãƒ¡ãƒ¢ï¼ˆ3è¡Œï¼‰â€¦å°åˆ·/PNGã«ã‚‚åæ˜ "></textarea>
    </div>
  </div>

  <div class="panel hint">
    <strong id="opMemoTitle">æ“ä½œãƒ¡ãƒ¢</strong>
    <ul style="margin:8px 0 0; padding-left:18px;">
      <li id="memoWall"><b>å£ç·š/å£æ¶ˆã—</b>ï¼šãƒ‰ãƒ©ãƒƒã‚°ã§æ ¼å­ã®è¾ºã«ã‚¹ãƒŠãƒƒãƒ—ã—ã¦æç”»ï¼ˆå£è‰²ãƒ»ç·šç¨®ï¼»å®Ÿç·š/ç‚¹ç·šï¼½ã¯é¸æŠå¯ï¼‰ã€‚</li>
      <li id="memoFill"><b>å¡—ã‚Š/å¡—æ¶ˆã—</b>ï¼šã‚¯ãƒªãƒƒã‚¯ã§1ãƒã‚¹ã€‚<span class="kbd">Shift</span>+ã‚¯ãƒªãƒƒã‚¯ï¼ˆPCï¼‰ã¾ãŸã¯ <span class="kbd">ç¯„å›²</span>ONï¼ˆã‚¹ãƒãƒ›/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆï¼‰ã§ã€å£ã«åŒºåˆ‡ã‚‰ã‚ŒãŸç¯„å›²ã‚’å¡—ã‚Šã¤ã¶ã—ã€‚</li>
      <li id="memoIcon"><b>ã‚¢ã‚¤ã‚³ãƒ³/ã‚¢ã‚¤æ¶ˆã—</b>ï¼šã‚»ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã§é…ç½®/å‰Šé™¤ï¼ˆãƒ¡ãƒ¢ã¯ä»»æ„ï¼‰ã€‚</li>
      <li id="memoText"><b>æ–‡å­—</b>ï¼šã‚»ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯â†’å…¥åŠ›â†’OKã§ç¢ºå®šã€‚</li>
      <li id="memoUndo">Undo/Redoï¼š<span class="kbd">Ctrl+Z</span> / <span class="kbd">Ctrl+Y</span> / <span class="kbd">Ctrl+Shift+Z</span></li>
      <li id="memoShortcut">ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼š<span class="kbd">W</span>å£ç·š / <span class="kbd">E</span>å£æ¶ˆã— / <span class="kbd">F</span>å¡—ã‚Š / <span class="kbd">D</span>å¡—æ¶ˆã— / <span class="kbd">I</span>ã‚¢ã‚¤ã‚³ãƒ³ / <span class="kbd">O</span>ã‚¢ã‚¤æ¶ˆã— / <span class="kbd">T</span>æ–‡å­— / å£è‰² <span class="kbd">1</span><span class="kbd">2</span><span class="kbd">3</span></li>
      <li id="memoAutosave">è‡ªå‹•ä¿å­˜ï¼šã“ã®ãƒ–ãƒ©ã‚¦ã‚¶å†…ã«è‡ªå‹•ä¿å­˜ï¼ˆlocalStorageï¼‰ã€‚</li>
    </ul>
</div>
</main>

<script>
(() => {
  "use strict";

  // ===== Config =====
  const GRID = 27;
  const CELL = 20;
  const MARGIN_CELLS = 1;               // â˜… å‘¨å›²1ãƒã‚¹
  const OFFSET = MARGIN_CELLS * CELL;   // â˜… æç”»ã‚ªãƒ•ã‚»ãƒƒãƒˆ(px)
  const GRID_PX = GRID * CELL;          // 540
  const CANVAS_PX = (GRID + MARGIN_CELLS*2) * CELL; // 580

  const BOTTOM_MEMO_MAX_CHARS = 100;
  const BOTTOM_MEMO_MAX_LINES = 3;

// â˜… ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆæŒ‡å®š9è‰²ï¼‰
const PALETTE = [
  "#FFFFFF",
  "#000000",
  "#CCCCCC",
  "#00FFFF",
  "#FFFF00",
  "#FF6600",
  "#00FF00",
  "#FF8C00",
  "#9370DB",
];

// â˜… å£è‰²ï¼ˆé»’/èµ¤/é’ï¼‰
const WALL_COLORS = [
  "#111111",
  "#ff0000",
  "#1E90FF",
];

  // ===== DOM =====
  const canvas = document.getElementById("map");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const octx = overlay.getContext("2d");
  const swatchesEl = document.getElementById("swatches");
  const wallSwatchesEl = document.getElementById("wallSwatches");
  const mapTitleInput = document.getElementById("mapTitle");
  const coordDisplayEl = document.getElementById("coordDisplay");
  const highlightToggleBtn = document.getElementById("highlightToggle");
  const bottomMemoEl = document.getElementById("bottomMemo");
  const bottomMemoLabelEl = document.getElementById("bottomMemoLabel");
  const bottomMemoCounterEl = document.getElementById("bottomMemoCounter");
  const langSelect = document.getElementById("langSelect");
  const loadJsonSpan = document.getElementById("loadJsonSpan");
  const lblTools = document.getElementById("lblTools");
  const lblFillColor = document.getElementById("lblFillColor");
  const lblWallColor = document.getElementById("lblWallColor");
  const lblLineWidth = document.getElementById("lblLineWidth");
  const lblLineStyle = document.getElementById("lblLineStyle");
  const wallStyleSel = document.getElementById("wallStyle");
  const lblWallMark = document.getElementById("lblWallMark");
  const wallMarkSel = document.getElementById("wallMark");
  const lblIcons = document.getElementById("lblIcons");
  const lblHistory = document.getElementById("lblHistory");
  const lblSaveExport = document.getElementById("lblSaveExport");
  const opMemoTitle = document.getElementById("opMemoTitle");
  const memoWall = document.getElementById("memoWall");
  const memoFill = document.getElementById("memoFill");
  const memoIcon = document.getElementById("memoIcon");
  const memoText = document.getElementById("memoText");
  const memoUndo = document.getElementById("memoUndo");
  const memoShortcut = document.getElementById("memoShortcut");
  const memoAutosave = document.getElementById("memoAutosave");

  const toolButtons = {
    wall: document.getElementById("toolWall"),
    eraseWall: document.getElementById("toolEraseWall"),
    fill: document.getElementById("toolFill"),
    eraseFill: document.getElementById("toolEraseFill"),
    icon: document.getElementById("toolIcon"),
    eraseIcon: document.getElementById("toolEraseIcon"),
    text: document.getElementById("toolText"),
  };

  const bucketToggleBtn = document.getElementById("bucketToggle");
  let bucketMode = false;

  // Highlight toggle (UI only)
  if (highlightToggleBtn) {
    highlightToggleBtn.addEventListener("click", () => {
      showHighlight = !showHighlight;
      try { localStorage.setItem(HL_KEY, showHighlight ? "1" : "0"); } catch {}
      updateHighlightButton();
      drawOverlay();
    });
  }




  const wallWidthInput = document.getElementById("wallWidth");
  const iconTypeSel = document.getElementById("iconType");
  const iconNoteInput = document.getElementById("iconNote");

  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");
  const clearBtn = document.getElementById("clearBtn");
  const saveJsonBtn = document.getElementById("saveJsonBtn");
  const loadJsonInput = document.getElementById("loadJsonInput");
  const exportPngBtn = document.getElementById("exportPngBtn");
  const printBtn = document.getElementById("printBtn");

  // ===== UI-only state (not saved / not exported) =====
  const HL_KEY = "dm_showHighlight";
  let showHighlight = (() => {
    try {
      const v = localStorage.getItem(HL_KEY);
      if (v === null) return true;
      return v === "1";
    } catch {
      return true;
    }
  })();

  let selectedCell = null; // {x,y} in internal (top-left origin) coords

  function drawOverlay() {
    if (!overlay || !octx) return;
    octx.clearRect(0, 0, overlay.width, overlay.height);
    if (!showHighlight || !selectedCell) return;

    const x = OFFSET + selectedCell.x * CELL;
    const y = OFFSET + selectedCell.y * CELL;

    // Outer yellow outline (2px)
    octx.strokeStyle = "#FFFF00";
    octx.lineWidth = 2;
    octx.strokeRect(x + 1, y + 1, CELL - 2, CELL - 2);

    // Inner dark outline (1px) for visibility on yellow tiles
    octx.strokeStyle = "rgba(0,0,0,0.55)";
    octx.lineWidth = 1;
    octx.strokeRect(x + 3, y + 3, CELL - 6, CELL - 6);
  }

  function setSelectedCell(x, y) {
    selectedCell = { x, y };
    drawOverlay();
  }

  function clearSelectedCell() {
    selectedCell = null;
    drawOverlay();
  }

  // ===== i18n =====
  const ICON_DEFS = [
    { value: "ğŸšª", ja: "éšæ®µ", en: "Stairs" },
    { value: "âœ¨", ja: "ãƒãƒ¼ã‚±ãƒ³", en: "Haken" },
    { value: "ğŸ‘¹", ja: "æ•µ", en: "Enemy" },
    { value: "â—", ja: "ã‚¤ãƒ™ãƒ³ãƒˆ", en: "Event" },
    { value: "â›²", ja: "å‘½ã®äº•æˆ¸", en: "Fountain" },
    { value: "â˜ ", ja: "éºéª¸", en: "Remains" },
    { value: "ğŸ•³", ja: "ã‚·ãƒ¥ãƒ¼ãƒˆ", en: "Pitfall" },
    { value: "â™¨", ja: "å›å¾©", en: "Heal" },
    { value: "ğŸ§°", ja: "å®ç®±", en: "Treasure" },
    { value: "ğŸ‘¤", ja: "NPC", en: "NPC" },
    { value: "âŒ", ja: "å±é™º", en: "Danger" },
    { value: "ğŸ”¯", ja: "ãƒ¯ãƒ¼ãƒ—", en: "Warp" },
  ];

  const I18N = {
    ja: {
      labels: {
        tools: "ãƒ„ãƒ¼ãƒ«",
        fillColor: "å¡—ã‚Šè‰²",
        wallColor: "å£è‰²",
        lineWidth: "ç·šå¹…",
        lineStyle: "ç·šç¨®",
        wallMark: "ãƒãƒ¼ã‚¯",
        solid: "å®Ÿç·š",
        dashed: "ç‚¹ç·š",
        markNone: "ãªã—",
        markDoor: "æ‰‰ï¼‹",
        icons: "ã‚¢ã‚¤ã‚³ãƒ³",
        history: "å±¥æ­´",
        saveExport: "ä¿å­˜/å‡ºåŠ›",
        opMemo: "æ“ä½œãƒ¡ãƒ¢",        bottomMemo: "ãƒ¡ãƒ¢",
        bottomMemoFull: "ãƒ¡ãƒ¢ï¼ˆå°åˆ·ã€PNGã«ã‚‚åæ˜  / æœ€å¤§100æ–‡å­—ã¾ã§ï¼‰",
        remaining: "æ®‹ã‚Šï¼š{n}æ–‡å­—",
      },
      misc: { on: "ON", off: "OFF" },
      buttons: {
        wall: "å£ç·š",
        eraseWall: "å£æ¶ˆã—",
        fill: "å¡—ã‚Š",
        eraseFill: "å¡—æ¶ˆã—",
        bucket: "ç¯„å›²",
        highlight: "ãƒã‚¤ãƒ©ã‚¤ãƒˆ",
        icon: "ã‚¢ã‚¤ã‚³ãƒ³",
        eraseIcon: "ã‚¢ã‚¤æ¶ˆã—",
        text: "æ–‡å­—",
        clearAll: "å…¨æ¶ˆå»",
        saveJson: "JSONä¿å­˜",
        loadJson: "JSONèª­è¾¼",
        exportPng: "PNGæ›¸å‡º",
        print: "å°åˆ·",
      },
      placeholders: {
        mapTitle: "MAPåã‚’å…¥åŠ›ï¼ˆå°åˆ·ã«ã‚‚åæ˜ ï¼‰",
        iconNote: "ãƒ¡ãƒ¢(ä»»æ„)",
        bottomMemo: "ã“ã“ã«ãƒ¡ãƒ¢ï¼ˆ3è¡Œï¼‰â€¦å°åˆ·/PNGã«ã‚‚åæ˜ ï¼ˆæœ€å¤§100æ–‡å­—ï¼‰",
      },
      titles: {
        wall: "æ ¼å­ã®è¾ºã«å£ç·šã‚’å¼•ã",
        eraseWall: "å£ç·šã‚’æ¶ˆã™",
        fill: "ã‚»ãƒ«ã‚’å¡—ã‚‹",
        eraseFill: "å¡—ã‚Šã‚’æ¶ˆã™",
        bucket: "å¡—ã‚Š/å¡—æ¶ˆã—ã®ç¯„å›²(ãƒã‚±ãƒ„)ã€‚ã‚¹ãƒãƒ›ã¯ã“ã‚Œã‚’ON",
        lineStyle: "å£ç·šã®ç·šç¨®ï¼ˆå®Ÿç·š/ç‚¹ç·šï¼‰",
        wallMark: "å£ç·šã®ãƒãƒ¼ã‚¯ï¼ˆæ‰‰ãªã©ï¼‰",
        highlight: "é¸æŠã‚»ãƒ«ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã‚’åˆ‡æ›¿",
        icon: "çµµæ–‡å­—ã‚¢ã‚¤ã‚³ãƒ³ã‚’ç½®ã",
        eraseIcon: "ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ¶ˆã™",
        text: "ã‚»ãƒ«ã«çŸ­ã„ãƒ¡ãƒ¢æ–‡å­—ã‚’å…¥ã‚Œã‚‹",
        undo: "Undo (Ctrl+Z)",
        redo: "Redo (Ctrl+Y / Ctrl+Shift+Z)",
        clearAll: "å…¨æ¶ˆå»",
      },
      memo: {
        wall: "<b>å£ç·š/å£æ¶ˆã—</b>ï¼šãƒ‰ãƒ©ãƒƒã‚°ã§æ ¼å­ã®è¾ºã«ã‚¹ãƒŠãƒƒãƒ—ã—ã¦æç”»ï¼ˆå£è‰²ãƒ»ç·šç¨®ï¼»å®Ÿç·š/ç‚¹ç·šï¼½ãƒ»ãƒãƒ¼ã‚¯ï¼»ãªã—/æ‰‰ï¼‹ï¼½ã‚’é¸æŠå¯ï¼‰ã€‚",
        fill: "<b>å¡—ã‚Š/å¡—æ¶ˆã—</b>ï¼šã‚¯ãƒªãƒƒã‚¯ã§1ãƒã‚¹ã€‚<span class=\"kbd\">Shift</span>+ã‚¯ãƒªãƒƒã‚¯ï¼ˆPCï¼‰ã¾ãŸã¯ <span class=\"kbd\">ç¯„å›²</span>ONï¼ˆã‚¹ãƒãƒ›/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆï¼‰ã§ã€å£ã«åŒºåˆ‡ã‚‰ã‚ŒãŸç¯„å›²ã‚’å¡—ã‚Šã¤ã¶ã—ã€‚",
        icon: "<b>ã‚¢ã‚¤ã‚³ãƒ³/ã‚¢ã‚¤æ¶ˆã—</b>ï¼šã‚»ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã§é…ç½®/å‰Šé™¤ï¼ˆãƒ¡ãƒ¢ã¯ä»»æ„ï¼‰ã€‚",
        text: "<b>æ–‡å­—</b>ï¼šã‚»ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯â†’å…¥åŠ›â†’OKã§ç¢ºå®šã€‚",
        undo: "Undo/Redoï¼š<span class=\"kbd\">Ctrl+Z</span> / <span class=\"kbd\">Ctrl+Y</span> / <span class=\"kbd\">Ctrl+Shift+Z</span>",
        shortcut: "ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼š<span class=\"kbd\">W</span>å£ç·š / <span class=\"kbd\">E</span>å£æ¶ˆã— / <span class=\"kbd\">F</span>å¡—ã‚Š / <span class=\"kbd\">D</span>å¡—æ¶ˆã— / <span class=\"kbd\">I</span>ã‚¢ã‚¤ã‚³ãƒ³ / <span class=\"kbd\">O</span>ã‚¢ã‚¤æ¶ˆã— / <span class=\"kbd\">T</span>æ–‡å­— / å£è‰² <span class=\"kbd\">1</span><span class=\"kbd\">2</span><span class=\"kbd\">3</span>",
        autosave: "è‡ªå‹•ä¿å­˜ï¼šã“ã®ãƒ–ãƒ©ã‚¦ã‚¶å†…ã«è‡ªå‹•ä¿å­˜ï¼ˆlocalStorageï¼‰ã€‚",
      },
      dialogs: {
        cellTextPrompt: "ã‚»ãƒ«æ–‡å­—ï¼ˆçŸ­ã‚æ¨å¥¨ï¼‰",
        clearConfirm: "å…¨æ¶ˆå»ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ï¼Ÿ",
        jsonSizeMismatch: "ã“ã®JSONã¯ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºãŒä¸€è‡´ã—ã¾ã›ã‚“ã€‚",
        jsonLoadFail: "JSONèª­è¾¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚",
      },
      title: "3D Dungeon Mapping Assist (27x27)",
    },
    en: {
      labels: {
        tools: "Tools",
        fillColor: "Fill",
        wallColor: "Wall",
        lineWidth: "Width",
        lineStyle: "Style",
        wallMark: "Mark",
        solid: "Solid",
        dashed: "Dashed",
        markNone: "None",
        markDoor: "Door +",
        icons: "Icons",
        history: "History",
        saveExport: "Save/Export",
        opMemo: "How to use",        bottomMemo: "Notes",
        bottomMemoFull: "Notes (included in Print & PNG / up to 100 chars)",
        remaining: "Remaining: {n}",
      },
      misc: { on: "ON", off: "OFF" },
      buttons: {
        wall: "Wall",
        eraseWall: "Erase wall",
        fill: "Fill",
        eraseFill: "Erase fill",
        bucket: "Bucket",
        highlight: "Highlight",
        icon: "Icon",
        eraseIcon: "Erase icon",
        text: "Text",
        clearAll: "Clear all",
        saveJson: "Save JSON",
        loadJson: "Load JSON",
        exportPng: "Export PNG",
        print: "Print",
      },
      placeholders: {
        mapTitle: "Map title (shown on print/export)",
        iconNote: "Note (optional)",
        bottomMemo: "Notes (3 lines) â€” included in print/PNG (max 100 chars)",
      },
      titles: {
        wall: "Draw walls snapped to grid edges",
        eraseWall: "Erase walls",
        fill: "Paint a cell",
        eraseFill: "Erase paint",
        bucket: "Bucket fill (region by walls). Use this on touch devices",
        lineStyle: "Wall line style (Solid/Dashed)",
        wallMark: "Wall mark (e.g., doors)",
        highlight: "Toggle highlight of the selected cell",
        icon: "Place an emoji icon",
        eraseIcon: "Remove an icon",
        text: "Add a short text note",
        undo: "Undo (Ctrl+Z)",
        redo: "Redo (Ctrl+Y / Ctrl+Shift+Z)",
        clearAll: "Clear everything",
      },
      memo: {
        wall: "<b>Wall / Erase wall</b>: Drag to draw/erase snapped to grid edges (choose color, line style & mark).",
        fill: "<b>Fill / Erase fill</b>: Click to paint a single cell. Use <span class=\"kbd\">Shift</span>+Click (PC) or turn <span class=\"kbd\">Bucket</span> ON (mobile/tablet) to fill a region bounded by walls.",
        icon: "<b>Icon / Erase icon</b>: Click a cell to place/remove an icon (note is optional).",
        text: "<b>Text</b>: Click a cell â†’ enter text â†’ OK.",
        undo: "Undo/Redo: <span class=\"kbd\">Ctrl+Z</span> / <span class=\"kbd\">Ctrl+Y</span> / <span class=\"kbd\">Ctrl+Shift+Z</span>",
        shortcut: "Shortcuts: <span class=\"kbd\">W</span>Wall / <span class=\"kbd\">E</span>Erase wall / <span class=\"kbd\">F</span>Fill / <span class=\"kbd\">D</span>Erase fill / <span class=\"kbd\">I</span>Icon / <span class=\"kbd\">O</span>Erase icon / <span class=\"kbd\">T</span>Text / Wall color <span class=\"kbd\">1</span><span class=\"kbd\">2</span><span class=\"kbd\">3</span>",
        autosave: "Autosave: Saved automatically in this browser (localStorage).",
      },
      dialogs: {
        cellTextPrompt: "Cell text (keep it short)",
        clearConfirm: "Clear everything. Are you sure?",
        jsonSizeMismatch: "This JSON file has an incompatible grid size.",
        jsonLoadFail: "Failed to load JSON.",
      },
      title: "3D Dungeon Mapping Assist (27x27)",
    },
  };

  let currentLang = "ja";

  function updateHighlightButton() {
    if (!highlightToggleBtn) return;
    const label = I18N[currentLang].buttons.highlight;
    const stateText = showHighlight ? I18N[currentLang].misc.on : I18N[currentLang].misc.off;
    highlightToggleBtn.textContent = `${label}:${stateText}`;
    highlightToggleBtn.classList.toggle("active", showHighlight);
  }


  function renderIconOptions() {
    const current = iconTypeSel.value;
    iconTypeSel.innerHTML = "";
    const defs = ICON_DEFS;
    for (const d of defs) {
      const opt = document.createElement("option");
      opt.value = d.value;
      const name = (currentLang === "ja") ? d.ja : d.en;
      opt.textContent = `${d.value} ${name}`;
      iconTypeSel.appendChild(opt);
    }
    // restore selection if possible
    iconTypeSel.value = defs.some(d => d.value === current) ? current : defs[0].value;
  }

  function applyLanguage(lang) {
    currentLang = (lang === "en") ? "en" : "ja";
    try { localStorage.setItem("dm_lang", currentLang); } catch {}

    document.documentElement.lang = currentLang;
    document.title = I18N[currentLang].title;

    // labels
    if (lblTools) lblTools.textContent = I18N[currentLang].labels.tools;
    if (lblFillColor) lblFillColor.textContent = I18N[currentLang].labels.fillColor;
    if (lblWallColor) lblWallColor.textContent = I18N[currentLang].labels.wallColor;
    if (lblLineWidth) lblLineWidth.textContent = I18N[currentLang].labels.lineWidth;
    if (lblLineStyle) lblLineStyle.textContent = I18N[currentLang].labels.lineStyle;
    if (lblWallMark) lblWallMark.textContent = I18N[currentLang].labels.wallMark;
    if (lblIcons) lblIcons.textContent = I18N[currentLang].labels.icons;
    if (lblHistory) lblHistory.textContent = I18N[currentLang].labels.history;
    if (lblSaveExport) lblSaveExport.textContent = I18N[currentLang].labels.saveExport;
    if (opMemoTitle) opMemoTitle.textContent = I18N[currentLang].labels.opMemo;
    if (bottomMemoLabelEl) bottomMemoLabelEl.textContent = I18N[currentLang].labels.bottomMemoFull;
    updateBottomMemoCounter();

    // buttons
    toolButtons.wall.textContent = I18N[currentLang].buttons.wall;
    toolButtons.eraseWall.textContent = I18N[currentLang].buttons.eraseWall;
    toolButtons.fill.textContent = I18N[currentLang].buttons.fill;
    toolButtons.eraseFill.textContent = I18N[currentLang].buttons.eraseFill;
    bucketToggleBtn.textContent = I18N[currentLang].buttons.bucket;
    toolButtons.icon.textContent = I18N[currentLang].buttons.icon;
    toolButtons.eraseIcon.textContent = I18N[currentLang].buttons.eraseIcon;
    toolButtons.text.textContent = I18N[currentLang].buttons.text;

    clearBtn.textContent = I18N[currentLang].buttons.clearAll;
    saveJsonBtn.textContent = I18N[currentLang].buttons.saveJson;
    if (loadJsonSpan) loadJsonSpan.textContent = I18N[currentLang].buttons.loadJson;
    exportPngBtn.textContent = I18N[currentLang].buttons.exportPng;
    printBtn.textContent = I18N[currentLang].buttons.print;

    // placeholders
    mapTitleInput.placeholder = I18N[currentLang].placeholders.mapTitle;
    iconNoteInput.placeholder = I18N[currentLang].placeholders.iconNote;
    if (bottomMemoEl) bottomMemoEl.placeholder = I18N[currentLang].placeholders.bottomMemo;

    // titles/tooltips
    toolButtons.wall.title = I18N[currentLang].titles.wall;
    toolButtons.eraseWall.title = I18N[currentLang].titles.eraseWall;
    toolButtons.fill.title = I18N[currentLang].titles.fill;
    toolButtons.eraseFill.title = I18N[currentLang].titles.eraseFill;
    bucketToggleBtn.title = I18N[currentLang].titles.bucket;
    if (wallStyleSel) wallStyleSel.title = I18N[currentLang].titles.lineStyle;
    if (wallStyleSel) {
      const os = wallStyleSel.querySelector('option[value="solid"]');
      const od = wallStyleSel.querySelector('option[value="dashed"]');
      if (os) os.textContent = I18N[currentLang].labels.solid;
      if (od) od.textContent = I18N[currentLang].labels.dashed;
    }
    if (wallMarkSel) wallMarkSel.title = I18N[currentLang].titles.wallMark;
    if (wallMarkSel) {
      const on = wallMarkSel.querySelector('option[value="none"]');
      const od2 = wallMarkSel.querySelector('option[value="door"]');
      if (on) on.textContent = I18N[currentLang].labels.markNone;
      if (od2) od2.textContent = I18N[currentLang].labels.markDoor;
    }
    toolButtons.icon.title = I18N[currentLang].titles.icon;
    toolButtons.eraseIcon.title = I18N[currentLang].titles.eraseIcon;
    toolButtons.text.title = I18N[currentLang].titles.text;
    undoBtn.title = I18N[currentLang].titles.undo;
    redoBtn.title = I18N[currentLang].titles.redo;
    clearBtn.title = I18N[currentLang].titles.clearAll;

    if (highlightToggleBtn) highlightToggleBtn.title = I18N[currentLang].titles.highlight;
    updateHighlightButton();

    // memo text
    if (memoWall) memoWall.innerHTML = I18N[currentLang].memo.wall;
    if (memoFill) memoFill.innerHTML = I18N[currentLang].memo.fill;
    if (memoIcon) memoIcon.innerHTML = I18N[currentLang].memo.icon;
    if (memoText) memoText.innerHTML = I18N[currentLang].memo.text;
    if (memoUndo) memoUndo.innerHTML = I18N[currentLang].memo.undo;
    if (memoShortcut) memoShortcut.innerHTML = I18N[currentLang].memo.shortcut;
    if (memoAutosave) memoAutosave.innerHTML = I18N[currentLang].memo.autosave;

    renderIconOptions();
  }

  // init language
  const savedLang = (() => { try { return localStorage.getItem("dm_lang"); } catch { return null; } })();
  if (langSelect) {
    langSelect.value = (savedLang === "en") ? "en" : "ja";
    langSelect.addEventListener("change", () => applyLanguage(langSelect.value));
  }
  applyLanguage((savedLang === "en") ? "en" : "ja");


  // ===== State (layered) =====
  // cells[y][x] = color string or null
  // wallsH[y][x] = null or {color, style, mark} (horizontal edges), y:0..GRID, x:0..GRID-1
  // wallsV[y][x] = null or {color, style, mark} (vertical edges), y:0..GRID-1, x:0..GRID
  // style: "solid" | "dashed"
  // iconMap[y][x] = {type: emoji, note} or null
  // textMap[y][x] = string or ""
  const emptyState = () => ({
    version: 2,
    grid: GRID,
    cellSize: CELL,
    marginCells: MARGIN_CELLS,
    cells: Array.from({length: GRID}, () => Array.from({length: GRID}, () => null)),
    wallsH: Array.from({length: GRID+1}, () => Array.from({length: GRID}, () => null)),
    wallsV: Array.from({length: GRID}, () => Array.from({length: GRID+1}, () => null)),
    iconMap: Array.from({length: GRID}, () => Array.from({length: GRID}, () => null)),
    textMap: Array.from({length: GRID}, () => Array.from({length: GRID}, () => "")),
    meta: { title: "Dungeon Map", bottomMemo: "", updatedAt: new Date().toISOString() },
  });

  let state = emptyState();

  // ===== History (Undo/Redo) =====
  const MAX_HISTORY = 160;
  const undoStack = [];
  const redoStack = [];

  function snapshot() {
    try { return structuredClone(state); }
    catch { return JSON.parse(JSON.stringify(state)); }
  }

  function pushHistory() {
    undoStack.push(snapshot());
    if (undoStack.length > MAX_HISTORY) undoStack.shift();
    redoStack.length = 0;
    updateHistoryButtons();
    autosave();
  }

  function undo() {
    if (!undoStack.length) return;
    redoStack.push(snapshot());
    state = undoStack.pop();
    syncTitleUI();
    syncBottomMemoUI();
    updateHistoryButtons();
    autosave();
    draw();
  }

  function redo() {
    if (!redoStack.length) return;
    undoStack.push(snapshot());
    state = redoStack.pop();
    syncTitleUI();
    syncBottomMemoUI();
    updateHistoryButtons();
    autosave();
    draw();
  }

  function updateHistoryButtons() {
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }

  // ===== Tool handling =====
  const Tool = Object.freeze({
    WALL: "wall",
    ERASE_WALL: "eraseWall",
    FILL: "fill",
    ERASE_FILL: "eraseFill",
    ICON: "icon",
    ERASE_ICON: "eraseIcon",
    TEXT: "text",
  });
  let currentTool = Tool.WALL;

  function setTool(t) {
    currentTool = t;
    for (const [k, btn] of Object.entries(toolButtons)) {
      btn.classList.toggle("active", k === t);
    }
  }

  toolButtons.wall.onclick = () => setTool(Tool.WALL);
  toolButtons.eraseWall.onclick = () => setTool(Tool.ERASE_WALL);
  toolButtons.fill.onclick = () => setTool(Tool.FILL);
  toolButtons.eraseFill.onclick = () => setTool(Tool.ERASE_FILL);
  toolButtons.icon.onclick = () => setTool(Tool.ICON);
  toolButtons.eraseIcon.onclick = () => setTool(Tool.ERASE_ICON);
  toolButtons.text.onclick = () => setTool(Tool.TEXT);


  // ===== Bucket toggle (for touch devices) =====
  if (bucketToggleBtn) {
    bucketToggleBtn.onclick = () => {
      bucketMode = !bucketMode;
      bucketToggleBtn.classList.toggle("active", bucketMode);
    };
  }

  // ===== Palette UI =====
  let selectedColor = PALETTE[4]; // default yellow
  let selectedWallColor = WALL_COLORS[0]; // default black
  let selectedWallStyle = (() => { try { return localStorage.getItem("dm_wallStyle") || "solid"; } catch { return "solid"; } })();
  if (selectedWallStyle !== "dashed") selectedWallStyle = "solid";
  if (wallStyleSel) {
    wallStyleSel.value = selectedWallStyle;
    wallStyleSel.addEventListener("change", () => {
      selectedWallStyle = (wallStyleSel.value === "dashed") ? "dashed" : "solid";
      try { localStorage.setItem("dm_wallStyle", selectedWallStyle); } catch {}
    });
  }

  let selectedWallMark = (() => { try { return localStorage.getItem("dm_wallMark") || "none"; } catch { return "none"; } })();
  if (selectedWallMark !== "door") selectedWallMark = "none";
  if (wallMarkSel) {
    wallMarkSel.value = selectedWallMark;
    wallMarkSel.addEventListener("change", () => {
      selectedWallMark = (wallMarkSel.value === "door") ? "door" : "none";
      try { localStorage.setItem("dm_wallMark", selectedWallMark); } catch {}
    });
  }

  function renderSwatches() {
    swatchesEl.innerHTML = "";
    PALETTE.forEach((c) => {
      const d = document.createElement("div");
      d.className = "swatch" + (c === selectedColor ? " selected" : "");
      d.style.background = c;
      d.title = c;
      d.onclick = () => { selectedColor = c; renderSwatches(); };
      swatchesEl.appendChild(d);
    });
  }

  function renderWallSwatches() {
    wallSwatchesEl.innerHTML = "";
    WALL_COLORS.forEach((c) => {
      const d = document.createElement("div");
      d.className = "swatch" + (c === selectedWallColor ? " selected" : "");
      d.style.background = c;
      d.title = "å£è‰²: " + c;
      d.onclick = () => { selectedWallColor = c; renderWallSwatches(); };
      wallSwatchesEl.appendChild(d);
    });
  }

  renderSwatches();
  renderWallSwatches();
  drawOverlay();

  // ===== Helpers =====
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function setCoordDisplay(x, y) {
    if (!coordDisplayEl) return;
    const pad2 = (n) => String(n).padStart(2, "0");
    coordDisplayEl.textContent = `X:${pad2(x)} Y:${pad2(y)}`;
  }

  function toLocal(px, py) {
    // â˜… ã‚°ãƒªãƒƒãƒ‰é ˜åŸŸã«å¯¾ã™ã‚‹åº§æ¨™ï¼ˆä½™ç™½ã‚’é™¤å¤–ï¼‰
    const lx = clamp(px - OFFSET, 0, GRID_PX);
    const ly = clamp(py - OFFSET, 0, GRID_PX);
    return { lx, ly };
  }

  function canvasToGridPoint(px, py) {
    const {lx, ly} = toLocal(px, py);
    const x = clamp(Math.round(lx / CELL), 0, GRID);
    const y = clamp(Math.round(ly / CELL), 0, GRID);
    return {x, y};
  }

  function canvasToCell(px, py) {
    const {lx, ly} = toLocal(px, py);
    const x = clamp(Math.floor(lx / CELL), 0, GRID-1);
    const y = clamp(Math.floor(ly / CELL), 0, GRID-1);
    return {x, y};
  }


// ===== Region fill (bucket) =====
function hasWallBetweenCells(x, y, nx, ny) {
  // Adjacent cells only. Return true if there is ANY wall on the boundary.
  if (nx === x && ny === y - 1) return !!state.wallsH[y][x];       // top edge of (x,y)
  if (nx === x && ny === y + 1) return !!state.wallsH[y + 1][x];   // bottom edge
  if (nx === x - 1 && ny === y) return !!state.wallsV[y][x];       // left edge
  if (nx === x + 1 && ny === y) return !!state.wallsV[y][x + 1];   // right edge
  return true;
}

function bucketFillByWalls(sx, sy, newColorOrNull) {
  const target = (state.cells[sy][sx] ?? null);
  if (target === newColorOrNull) return;

  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const q = [[sx, sy]];
  let head = 0;
  visited[sy][sx] = true;

  const inBounds = (x, y) => (x >= 0 && x < GRID && y >= 0 && y < GRID);

  while (head < q.length) {
    const [x, y] = q[head++];

    if ((state.cells[y][x] ?? null) !== target) continue;

    state.cells[y][x] = newColorOrNull;

    const neigh = [[x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y]];
    for (const [nx, ny] of neigh) {
      if (!inBounds(nx, ny)) continue;
      if (visited[ny][nx]) continue;
      if (hasWallBetweenCells(x, y, nx, ny)) continue;

      // â€œåŒã˜è‰²/æœªå¡—ã‚Šâ€ã ã‘é€£çµã•ã›ã‚‹ï¼ˆäº‹æ•…ã‚Šã«ãã„ãƒã‚±ãƒ„å¡—ã‚Šï¼‰
      if ((state.cells[ny][nx] ?? null) !== target) continue;

      visited[ny][nx] = true;
      q.push([nx, ny]);
    }
  }
}

  function setWallBetween(a, b, colorOrNull) {
    // a,b are intersections (x,y). Must be adjacent (Manhattan distance 1).
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    if (Math.abs(dx) + Math.abs(dy) !== 1) return;

    if (dx === 1) {
      state.wallsH[a.y][a.x] = colorOrNull;
    } else if (dx === -1) {
      state.wallsH[a.y][b.x] = colorOrNull;
    } else if (dy === 1) {
      state.wallsV[a.y][a.x] = colorOrNull;
    } else if (dy === -1) {
      state.wallsV[b.y][a.x] = colorOrNull;
    }
  }

  // Step path (axis-aligned), diagonal resolves to dominant axis first.
  function applyWallPath(p0, p1, colorOrNull) {
    let cx = p0.x, cy = p0.y;
    const tx = p1.x, ty = p1.y;

    while (cx !== tx || cy !== ty) {
      const dx = tx - cx;
      const dy = ty - cy;

      let stepX = 0, stepY = 0;
      if (Math.abs(dx) >= Math.abs(dy) && dx !== 0) stepX = Math.sign(dx);
      else if (dy !== 0) stepY = Math.sign(dy);
      else if (dx !== 0) stepX = Math.sign(dx);

      const nx = cx + stepX;
      const ny = cy + stepY;

      setWallBetween({x:cx,y:cy}, {x:nx,y:ny}, colorOrNull);

      cx = nx; cy = ny;
    }
  }

  // ===== Draw =====
  function drawBackground() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function drawCells() {
    ctx.save();
    for (let y=0;y<GRID;y++){
      for (let x=0;x<GRID;x++){
        const c = state.cells[y][x];
        if (!c) continue;
        ctx.fillStyle = c;
        ctx.fillRect(OFFSET + x*CELL, OFFSET + y*CELL, CELL, CELL);
      }
    }
    ctx.restore();
  }

  function drawGrid() {
    ctx.save();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim() || "#b0b0b0";
    ctx.lineWidth = 1;

    // crisp 1px
    ctx.translate(0.5, 0.5);

    // vertical lines
    for (let i=0;i<=GRID;i++){
      const x = OFFSET + i * CELL;
      ctx.beginPath();
      ctx.moveTo(x, OFFSET);
      ctx.lineTo(x, OFFSET + GRID_PX);
      ctx.stroke();
    }
    // horizontal lines
    for (let j=0;j<=GRID;j++){
      const y = OFFSET + j * CELL;
      ctx.beginPath();
      ctx.moveTo(OFFSET, y);
      ctx.lineTo(OFFSET + GRID_PX, y);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Axis labels (0..26) shown in the margin row/column
  function drawAxes() {
    ctx.save();
    ctx.fillStyle = "#6b7280"; // muted gray
    ctx.font = "11px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // X axis: bottom margin row
    const yBottom = OFFSET + GRID_PX + CELL / 2;
    for (let x = 0; x < GRID; x++) {
      const cx = OFFSET + x * CELL + CELL / 2;
      ctx.fillText(String(x), cx, yBottom);
    }

    // Y axis: left margin column
    const xLeft = OFFSET - CELL / 2;
    for (let y = 0; y < GRID; y++) {
      const cy = OFFSET + y * CELL + CELL / 2;
      // Origin is bottom-left for displayed coordinates: (0,0) at the lower-left cell
      ctx.fillText(String(GRID - 1 - y), xLeft, cy);
    }

    ctx.restore();
  }

  function drawWalls() {
    const w = clamp(parseInt(wallWidthInput.value || "4",10), 2, 4);

    const toSpec = (v) => {
      if (!v) return null;
      if (typeof v === "string") return { color: v, style: "solid", mark: "none" };
      if (typeof v === "object") {
        const color = (typeof v.color === "string") ? v.color : null;
        if (!color) return null;
        const style = (v.style === "dashed") ? "dashed" : "solid";
        const mark = (v.mark === "door") ? "door" : "none";
        return { color, style, mark };
      }
      return null;
    };

    const drawDoorMark = (cx, cy, color, orient) => {
      // Draw a short bar crossing the wall at its center.
      // orient: "h" for horizontal wall (draw vertical bar), "v" for vertical wall (draw horizontal bar)
      const len = Math.round(Math.max(10, CELL * 0.28));
      const lw = Math.max(2, w - 1);
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lw;
      ctx.setLineDash([]);
      ctx.lineCap = "butt";
      ctx.beginPath();
      if (orient === "h") {
        // vertical bar crosses horizontal wall
        ctx.moveTo(cx, cy - len / 2);
        ctx.lineTo(cx, cy + len / 2);
      } else {
        // horizontal bar crosses vertical wall
        ctx.moveTo(cx - len / 2, cy);
        ctx.lineTo(cx + len / 2, cy);
      }
      ctx.stroke();
      ctx.restore();
    };

    const applyLineStyle = (style) => {
      if (style === "dashed") {
        const dash = Math.max(2, w);
        const gap  = dash + 2; // keep gap > width to avoid looking solid
        ctx.setLineDash([dash, gap]);
        ctx.lineCap = "butt";
      } else {
        ctx.setLineDash([]);
        ctx.lineCap = "square";
      }
    };

    ctx.save();
    ctx.lineWidth = w;

    // horizontal
    for (let y=0;y<=GRID;y++){
      for (let x=0;x<GRID;x++){
        const spec = toSpec(state.wallsH[y][x]);
        if (!spec) continue;
        ctx.strokeStyle = spec.color;
        applyLineStyle(spec.style);
        const x0 = OFFSET + x*CELL;
        const y0 = OFFSET + y*CELL;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x0 + CELL, y0);
        ctx.stroke();
        if (spec.mark === "door") {
          const cx = x0 + CELL/2;
          const cy = y0; // centered on the wall line
          drawDoorMark(cx, cy, spec.color, "h");
        }
      }
    }
    // vertical
    for (let y=0;y<GRID;y++){
      for (let x=0;x<=GRID;x++){
        const spec = toSpec(state.wallsV[y][x]);
        if (!spec) continue;
        ctx.strokeStyle = spec.color;
        applyLineStyle(spec.style);
        const x0 = OFFSET + x*CELL;
        const y0 = OFFSET + y*CELL;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x0, y0 + CELL);
        ctx.stroke();
        if (spec.mark === "door") {
          const cx = x0; // centered on the wall line
          const cy = y0 + CELL/2;
          drawDoorMark(cx, cy, spec.color, "v");
        }
      }
    }

    ctx.restore();
  }

  function drawIconsAndText() {
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (let y=0;y<GRID;y++){
      for (let x=0;x<GRID;x++){
        const icon = state.iconMap[y][x];
        const text = state.textMap[y][x];

        const cx = OFFSET + x*CELL + CELL/2;
        const cy = OFFSET + y*CELL + CELL/2;

        if (icon) {
          // emoji icon
          ctx.font = "18px system-ui, 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji'";
          ctx.fillStyle = "#111";
          ctx.fillText(icon.type, cx, cy - 2);

          if (icon.note) {
            ctx.font = "10px system-ui";
            ctx.fillStyle = "#374151";
            ctx.fillText(icon.note, cx, cy + 12);
          }
        }

        if (text) {
          ctx.fillStyle = "#111";
          ctx.font = "12px system-ui";
          if (icon) {
            // small corner memo if icon exists
            ctx.textAlign = "left";
            ctx.textBaseline = "bottom";
            ctx.fillText(text, OFFSET + x*CELL + 2, OFFSET + y*CELL + CELL - 2);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
          } else {
            ctx.fillText(text, cx, cy);
          }
        }
      }
    }

    ctx.restore();
  }

  function draw() {
    drawBackground();

    // layers: fill -> grid -> walls -> icons/text
    drawCells();
    drawGrid();
    drawAxes();
    drawWalls();
    drawIconsAndText();
  }

  // ===== Pointer interactions =====
  let isPointerDown = false;
  let lastGridPt = null;

  function getCanvasPos(e) {
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) * (canvas.width / r.width);
    const y = (e.clientY - r.top) * (canvas.height / r.height);
    return {x, y};
  }

  function inGridArea(px, py) {
    return (px >= OFFSET && px <= OFFSET + GRID_PX && py >= OFFSET && py <= OFFSET + GRID_PX);
  }

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    isPointerDown = true;

    const {x,y} = getCanvasPos(e);

    // Ignore interactions on the margin area (where axis labels live)
    if (!inGridArea(x, y)) {
      isPointerDown = false;
      lastGridPt = null;
      return;
    }


    // Show tapped cell coordinate
    const cc = canvasToCell(x, y);
    // Display coordinates with origin at bottom-left
    setCoordDisplay(cc.x, GRID - 1 - cc.y);
    setSelectedCell(cc.x, cc.y);

    if (currentTool === Tool.WALL || currentTool === Tool.ERASE_WALL) {
      const p = canvasToGridPoint(x,y);
      lastGridPt = p;
      pushHistory();
    } else if (currentTool === Tool.FILL || currentTool === Tool.ERASE_FILL) {
      pushHistory();
      const c = canvasToCell(x,y);
      const next = (currentTool === Tool.FILL) ? selectedColor : null;

      if (e.shiftKey || bucketMode) {
        bucketFillByWalls(c.x, c.y, next);
      } else {
        state.cells[c.y][c.x] = next;
      }

      stampUpdated();
      draw();
    } else if (currentTool === Tool.ICON || currentTool === Tool.ERASE_ICON) {
      pushHistory();
      const c = canvasToCell(x,y);
      if (currentTool === Tool.ICON) {
        state.iconMap[c.y][c.x] = { type: iconTypeSel.value, note: (iconNoteInput.value || "").trim() };
      } else {
        state.iconMap[c.y][c.x] = null;
      }
      stampUpdated();
      draw();
    } else if (currentTool === Tool.TEXT) {
      pushHistory();
      const c = canvasToCell(x,y);
      const current = state.textMap[c.y][c.x] || "";
      const next = prompt(I18N[currentLang].dialogs.cellTextPrompt, current);
      if (next !== null) {
        state.textMap[c.y][c.x] = String(next).slice(0, 24);
        stampUpdated();
        draw();
      }
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!isPointerDown) return;
    if (!(currentTool === Tool.WALL || currentTool === Tool.ERASE_WALL)) return;

    const {x,y} = getCanvasPos(e);
    const p = canvasToGridPoint(x,y);

    if (!lastGridPt) { lastGridPt = p; return; }
    if (p.x === lastGridPt.x && p.y === lastGridPt.y) return;

    const val = (currentTool === Tool.WALL) ? { color: selectedWallColor, style: selectedWallStyle, mark: selectedWallMark } : null;
    applyWallPath(lastGridPt, p, val);
    lastGridPt = p;

    stampUpdated(false);
    draw();
  });

  canvas.addEventListener("pointerup", (e) => {
    isPointerDown = false;
    lastGridPt = null;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });
  canvas.addEventListener("pointercancel", () => {
    isPointerDown = false;
    lastGridPt = null;
  });

  canvas.addEventListener("contextmenu", (e) => e.preventDefault());


  function sanitizeBottomMemo(raw){
    let t = String(raw || "").replace(/\r\n/g, "\n");
    // limit lines
    let lines = t.split("\n");
    if (lines.length > BOTTOM_MEMO_MAX_LINES) lines = lines.slice(0, BOTTOM_MEMO_MAX_LINES);
    t = lines.join("\n");
    // limit chars (simple length)
    if (t.length > BOTTOM_MEMO_MAX_CHARS) t = t.slice(0, BOTTOM_MEMO_MAX_CHARS);
    // normalize: if only whitespace/newlines, treat as empty
    if (t.replace(/\n/g, "").trim() === "") return "";
    return t;
  }

  function countLines(str){
    if (str === "") return 1;
    return String(str).split("\n").length;
  }

  function updateBottomMemoCounter(){
    if (!bottomMemoEl || !bottomMemoCounterEl) return;
    const t = sanitizeBottomMemo(bottomMemoEl.value);
    const remain = Math.max(0, BOTTOM_MEMO_MAX_CHARS - t.length);
    const label = I18N[currentLang].labels.remaining.replace("{n}", String(remain));
    bottomMemoCounterEl.textContent = (currentLang === "ja") ? `ï¼ˆ${label}ï¼‰` : `(${label})`;
  }

  function commitTitleAndMemoNow(){
    // Flush debounced updates so Export/Print always reflects latest input
    try { clearTimeout(titleDebounce); } catch {}
    try { clearTimeout(memoDebounce); } catch {}
    state.meta = state.meta || {};
    const titleNow = String(mapTitleInput.value || "").trim();
    state.meta.title = titleNow || "Dungeon Map";

    const memoNow = sanitizeBottomMemo(bottomMemoEl ? bottomMemoEl.value : (state.meta.bottomMemo || ""));
    if (bottomMemoEl && bottomMemoEl.value !== memoNow) bottomMemoEl.value = memoNow;
    state.meta.bottomMemo = memoNow;
    stampUpdated(false);
    updateBottomMemoCounter();
  }

  // ===== Title binding =====
  function syncTitleUI() {
    mapTitleInput.value = state.meta?.title ?? "";
  }


  function syncBottomMemoUI() {
    if (!bottomMemoEl) return;
    const v = sanitizeBottomMemo(state.meta?.bottomMemo ?? "");
    bottomMemoEl.value = v;
    if (state.meta) state.meta.bottomMemo = v;
    updateBottomMemoCounter();
  }

  let titleDebounce = null;
  mapTitleInput.addEventListener("input", () => {
    const v = mapTitleInput.value;
    // Undoå±¥æ­´ã¯å¢—ã‚„ã•ãšã€ä¸€å®šæ™‚é–“ã§stateã¸åæ˜ 
    clearTimeout(titleDebounce);
    titleDebounce = setTimeout(() => {
      state.meta = state.meta || {};
      state.meta.title = v.trim() || "Dungeon Map";
      stampUpdated();
    }, 150);
  });

  let memoDebounce = null;
  bottomMemoEl?.addEventListener("input", () => {
    const sanitized = sanitizeBottomMemo(bottomMemoEl.value);
    if (bottomMemoEl.value !== sanitized) bottomMemoEl.value = sanitized;
    updateBottomMemoCounter();
    clearTimeout(memoDebounce);
    memoDebounce = setTimeout(() => {
      state.meta = state.meta || {};
      state.meta.bottomMemo = sanitizeBottomMemo(bottomMemoEl.value);
      stampUpdated();
    }, 150);
  });

  // Prevent creating more than max lines via Enter (2æ®µæ§‹ãˆã®1æ®µç›®)
  bottomMemoEl?.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    const lines = countLines(bottomMemoEl.value);
    if (lines >= BOTTOM_MEMO_MAX_LINES) e.preventDefault();
  });

  function stampUpdated(saveNow=true) {
    state.meta = state.meta || {};
    state.meta.updatedAt = new Date().toISOString();
    autosave(saveNow);
  }

  // ===== Buttons =====
  undoBtn.onclick = undo;
  redoBtn.onclick = redo;

  clearBtn.onclick = () => {
    if (!confirm(I18N[currentLang].dialogs.clearConfirm)) return;
    pushHistory();
    state = emptyState();
    syncTitleUI();
    syncBottomMemoUI();
    autosave(true);
    draw();
  };

    function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function wrapTextByChars(ctx, text, maxWidth){
    const out = [];
    let line = "";
    for (const ch of String(text)) {
      const test = line + ch;
      if (ctx.measureText(test).width <= maxWidth) {
        line = test;
      } else {
        if (line) out.push(line);
        line = ch;
      }
    }
    if (line) out.push(line);
    return out.length ? out : [""];
  }

function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  saveJsonBtn.onclick = () => {
    const data = JSON.stringify(state, null, 2);
    const blob = new Blob([data], {type:"application/json"});
    const ts = new Date().toISOString().replace(/[:.]/g,"-");
    downloadBlob(blob, `dungeon_map_${ts}.json`);
  };

  function normalizeLoaded(obj) {
    // æ—§ç‰ˆã®å£ãƒ‡ãƒ¼ã‚¿ã‚’æ­£è¦åŒ–
    // - true -> {color:"#111111", style:"solid"} ï¼ˆæ—§æŒ™å‹•äº’æ›ï¼‰
    // - "#RRGGBB" -> {color: "#RRGGBB", style:"solid"}
    // - {color, style} -> ãã®ã¾ã¾ï¼ˆstyleã¯ solid/dashed ã«ä¸¸ã‚ï¼‰
    if (!obj) return obj;

    const normWall = (v) => {
      if (v === true) return { color: "#111111", style: "solid", mark: "none" };
      if (v === false || v == null) return null;
      if (typeof v === "string") return { color: v, style: "solid", mark: "none" };
      if (typeof v === "object") {
        const color = (typeof v.color === "string") ? v.color : null;
        if (!color) return null;
        const style = (v.style === "dashed") ? "dashed" : "solid";
        const mark = (v.mark === "door") ? "door" : "none";
        return { color, style, mark };
      }
      return null;
    };

    if (Array.isArray(obj.wallsH)) {
      for (let y=0;y<obj.wallsH.length;y++){
        for (let x=0;x<obj.wallsH[y].length;x++){
          obj.wallsH[y][x] = normWall(obj.wallsH[y][x]);
        }
      }
    }
    if (Array.isArray(obj.wallsV)) {
      for (let y=0;y<obj.wallsV.length;y++){
        for (let x=0;x<obj.wallsV[y].length;x++){
          obj.wallsV[y][x] = normWall(obj.wallsV[y][x]);
        }
      }
    }

    obj.meta = obj.meta || {};
    obj.meta.title = (obj.meta.title || "Dungeon Map");
    obj.meta.bottomMemo = sanitizeBottomMemo(String(obj.meta.bottomMemo || ""));
    obj.meta.updatedAt = new Date().toISOString();
    obj.version = obj.version || 2;
    obj.grid = GRID;
    obj.cellSize = CELL;
    obj.marginCells = MARGIN_CELLS;
    return obj;
  }

  loadJsonInput.addEventListener("change", async () => {
    const file = loadJsonInput.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const obj = normalizeLoaded(JSON.parse(text));

      if (!obj || obj.grid !== GRID) {
        alert(I18N[currentLang].dialogs.jsonSizeMismatch);
        return;
      }
      pushHistory();
      state = obj;
      clearSelectedCell();
      syncTitleUI();
    syncBottomMemoUI();
      autosave(true);
      draw();
    } catch (err) {
      console.error(err);
      alert(I18N[currentLang].dialogs.jsonLoadFail);
    } finally {
      loadJsonInput.value = "";
    }
  });

exportPngBtn.onclick = () => {
  commitTitleAndMemoNow();
  draw();

  const title = String((state.meta?.title ?? mapTitleInput.value ?? "Dungeon Map") || "").trim();
  const headerH = title ? 44 : 0;

  const notesRaw = String(state.meta?.bottomMemo || "");
  const notesLabel = (currentLang === "en") ? "Notes" : "ãƒ¡ãƒ¢";

  const gap = 18;
  const labelH = 16;
  const boxPad = 14;
  const lineH = 16;
  const boxH = boxPad * 2 + lineH * BOTTOM_MEMO_MAX_LINES;

  // åˆæˆã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆã‚¿ã‚¤ãƒˆãƒ« + MAP + ä¸‹éƒ¨ãƒ¡ãƒ¢ï¼‰
  const out = document.createElement("canvas");
  out.width = canvas.width;
  out.height = headerH + canvas.height + gap + labelH + 6 + boxH;
  const octx = out.getContext("2d");

  // background
  octx.fillStyle = "#fff";
  octx.fillRect(0, 0, out.width, out.height);

  // title header
  if (headerH) {
    octx.fillStyle = "#111";
    octx.font = "20px system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans JP', 'Hiragino Sans', 'Yu Gothic', sans-serif";
    octx.textAlign = "center";
    octx.textBaseline = "middle";
    octx.fillText(title, out.width / 2, headerH / 2);

    octx.strokeStyle = "#e5e7eb";
    octx.lineWidth = 1;
    octx.beginPath();
    octx.moveTo(20, headerH - 0.5);
    octx.lineTo(out.width - 20, headerH - 0.5);
    octx.stroke();
  }

  // map
  octx.drawImage(canvas, 0, headerH);

  // notes label & box
  const ny = headerH + canvas.height + gap;
  octx.fillStyle = "#444";
  octx.font = "13px system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans JP', 'Hiragino Sans', 'Yu Gothic', sans-serif";
  octx.textAlign = "left";
  octx.textBaseline = "top";
  octx.fillText(notesLabel, 10, ny);

  const boxY = ny + labelH + 6;
  const boxX = 10;
  const boxW = out.width - 20;

  // box
  octx.strokeStyle = "#999";
  octx.lineWidth = 1;
  // rounded rect
  roundRect(octx, boxX, boxY, boxW, boxH, 10);
  octx.stroke();

  // text (wrap + clip)
  octx.save();
  octx.beginPath();
  octx.rect(boxX + boxPad, boxY + boxPad, boxW - boxPad * 2, boxH - boxPad * 2);
  octx.clip();

  octx.fillStyle = "#111";
  octx.font = "13px system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans JP', 'Hiragino Sans', 'Yu Gothic', sans-serif";
  octx.textBaseline = "top";

  const maxTextW = boxW - boxPad * 2;
  const logicalLines = sanitizeBottomMemo(notesRaw).split("\n");
  const wrapped = [];
  for (const ln of logicalLines) {
    if (ln === "") { wrapped.push(""); continue; }
    wrapped.push(...wrapTextByChars(octx, ln, maxTextW));
  }

  for (let i = 0; i < Math.min(BOTTOM_MEMO_MAX_LINES, wrapped.length); i++) {
    octx.fillText(wrapped[i], boxX + boxPad, boxY + boxPad + i * lineH);
  }
  octx.restore();

  out.toBlob((blob) => {
    if (!blob) return;
    const ts = new Date().toISOString().replace(/[:.]/g,"-");
    downloadBlob(blob, `dungeon_map_${ts}.png`);
  }, "image/png");
};

  // â˜… å°åˆ·ï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãªã—ï¼šiframeæ–¹å¼ï¼‰
  printBtn.onclick = () => {
    commitTitleAndMemoNow();
    draw();
    const dataUrl = canvas.toDataURL("image/png");

    const old = document.getElementById("printFrame");
    if (old) old.remove();

    const iframe = document.createElement("iframe");
    iframe.id = "printFrame";
    iframe.style.position = "fixed";
    iframe.style.right = "0";
    iframe.style.bottom = "0";
    iframe.style.width = "0";
    iframe.style.height = "0";
    iframe.style.border = "0";
    document.body.appendChild(iframe);

    const doc = iframe.contentWindow.document;

    const title = escapeHtml(state.meta?.title || "Dungeon Map");
    const now = new Date().toLocaleString();

    const notesRaw = String(state.meta?.bottomMemo || "");
    const notesText = escapeHtml(notesRaw);
    const notesLabel = (currentLang === "en") ? "Notes" : "ãƒ¡ãƒ¢";

    doc.open();
    doc.write(`
      <!doctype html>
      <html>
      <head>
        <meta charset="utf-8" />
        <title>${title}</title>
        <style>
          @page { margin: 12mm; }
          body { margin: 0; font-family: system-ui, sans-serif; }
          h1 { margin: 0 0 6mm; font-size: 18px; text-align: center; }
          .wrap { padding: 10mm; }
          .imgWrap { display:flex; justify-content:center; }
          img { max-width: 100%; height: auto; }
          .meta { text-align:center; color:#444; font-size:12px; margin-top:5mm; }

          .notes { margin-top: 6mm; }
          .notesLabel { font-size: 12px; color:#444; margin-bottom: 2mm; text-align:left; }
          .notesBox { border:1px solid #999; border-radius:8px; padding:6mm; white-space:pre-wrap; font-size:12px; line-height:1.35; min-height: calc(1.35em * 3); }

      
    #coordRow{
      display:flex;
      justify-content:flex-end;
      margin-top:8px;
    }
    #coordDisplay{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px;
      color:var(--muted);
      background:var(--ui);
      border:1px solid var(--ui2);
      border-radius:10px;
      padding:4px 8px;
      min-width:92px;
      text-align:right;
      user-select:none;
    }

  </style>
      </head>
      <body>
        <div class="wrap">
          <h1>${title}</h1>
          <div class="imgWrap">
            <img id="pimg" src="${dataUrl}" alt="Dungeon Map" />
          </div>

          <div class="notes">
            <div class="notesLabel">${notesLabel}</div>
            <div class="notesBox">${notesText}</div>
          </div>
          <div class="meta">${title} / ${now}</div>
        </div>
        <script>
          const img = document.getElementById('pimg');
          img.onload = () => {
            setTimeout(() => {
              window.focus();
              window.print();
            }, 80);
          };
        <\/script>
      </body>
      </html>
    `);
    doc.close();
  };

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
    }[c]));
  }

  // ===== Keyboard shortcuts =====
window.addEventListener("keydown", (e) => {
  // å…¥åŠ›ä¸­ã¯ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆèª¤çˆ†ã‚’é¿ã‘ã‚‹ï¼ˆCtrlç³»ã‚‚å«ã‚åŸºæœ¬ãƒ–ãƒ©ã‚¦ã‚¶ã«ä»»ã›ã‚‹ï¼‰
  const t = e.target;
  const tag = (t?.tagName || "").toLowerCase();
  const isTyping = tag === "input" || tag === "textarea" || tag === "select" || t?.isContentEditable;
  if (isTyping) return;

  // Undo / Redo
  const z = (e.key === "z" || e.key === "Z");
  const y = (e.key === "y" || e.key === "Y");
  if (e.ctrlKey && z && !e.shiftKey) { e.preventDefault(); undo(); return; }
  if (e.ctrlKey && (y || (z && e.shiftKey))) { e.preventDefault(); redo(); return; }

  // Ctrl/Alt/Meta ä½µç”¨ã¯ OS/ãƒ–ãƒ©ã‚¦ã‚¶å´ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’å„ªå…ˆ
  if (e.ctrlKey || e.metaKey || e.altKey) return;

  // å£è‰²ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼ˆ1/2/3ï¼‰
  if (e.key === "1" || e.key === "2" || e.key === "3") {
    const idx = parseInt(e.key, 10) - 1;
    selectedWallColor = WALL_COLORS[idx] || selectedWallColor;
    renderWallSwatches();
    return;
  }

  // ãƒ„ãƒ¼ãƒ«åˆ‡æ›¿
  const k = e.key.toLowerCase();
  if (k === "w") setTool(Tool.WALL);
  else if (k === "e") setTool(Tool.ERASE_WALL);
  else if (k === "f") setTool(Tool.FILL);
  else if (k === "d") setTool(Tool.ERASE_FILL);
  else if (k === "i") setTool(Tool.ICON);
  else if (k === "o") setTool(Tool.ERASE_ICON);
  else if (k === "t") setTool(Tool.TEXT);
});

// ===== Autosave =====
  const LS_KEY = "dungeon_mapper_27x27_v2_margin1";
  function autosave(force=false) {
    if (!force) {
      if (autosave._t) return;
      autosave._t = setTimeout(() => {
        autosave._t = null;
        try { localStorage.setItem(LS_KEY, JSON.stringify(state)); } catch {}
      }, 250);
    } else {
      try { localStorage.setItem(LS_KEY, JSON.stringify(state)); } catch {}
    }
  }

  function autoload() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const obj = normalizeLoaded(JSON.parse(raw));
      if (obj && obj.grid === GRID) state = obj;
    } catch {}
  }

  // ===== Init =====
  // enforce canvas size (safety)
  canvas.width = CANVAS_PX;
  canvas.height = CANVAS_PX;

  autoload();
  syncTitleUI();
  syncBottomMemoUI();
  updateHistoryButtons();
  draw();

})();
</script>

</body>
</html>
